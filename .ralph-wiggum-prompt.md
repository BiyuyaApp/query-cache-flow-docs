# Query Cache Flow Documentation Build Loop

## Mission
Build complete, production-ready documentation for the **Query Cache Flow** framework - a TanStack Query cache key management system that integrates with KUBB code generation.

## Philosophy to Communicate
**REST → OpenAPI → KUBB → Autogenerated wrappers with built-in invalidation → Zero-thought usage**

The goal: Developers write no cache keys manually. They get type-safe, automatically invalidating queries with zero cognitive overhead.

---

## Phase 1: Landing Page (iterations 1-15)

### Create: `landing/index.html`
A single-file, beautiful HTML landing page that:
- **Hero Section**: Query Cache Flow title with tagline "Zero-thought cache management for TanStack Query"
- **Problem Statement**: Cache invalidation is hard, manual query keys are error-prone
- **Solution Visual**: Animated or static diagram showing the flow: REST → OpenAPI → KUBB → Wrappers
- **Code Examples**: Show before/after - manual vs Query Cache Flow approach
- **Features Grid**: QueryGroups, CRUD Factory, Smart Invalidation, Type Safety
- **Quick Start**: npm install + basic setup code
- **CTA**: Links to documentation

### Design Requirements (invoke /ui-ux-pro-max):
- Modern, clean design (dark mode preferred)
- Gradient accents (blue to purple tech feel)
- Syntax-highlighted code blocks
- Responsive (mobile-first)
- No external dependencies (inline CSS, no frameworks)
- Smooth scroll, subtle animations
- Professional typography (system fonts or Google Fonts CDN)

### SEO Requirements (invoke /seo-optimizer):
- Meta tags (title, description, og:image)
- Semantic HTML5 structure
- Schema.org markup for software documentation
- Fast loading (inline critical CSS)

### Verification:
- Use /playwright-skill to screenshot the page at desktop and mobile widths
- Verify all sections render correctly
- Check that code blocks are readable

---

## Phase 2: Docusaurus Setup (iterations 16-25)

### Create: `docs/` directory with Docusaurus structure

```
docs/
├── docusaurus.config.js
├── package.json
├── sidebars.js
├── static/
│   └── img/
├── src/
│   ├── css/
│   │   └── custom.css
│   └── pages/
│       └── index.js (redirect to docs)
└── docs/
    ├── intro.md
    ├── getting-started/
    ├── core-concepts/
    ├── api-reference/
    ├── patterns/
    └── advanced/
```

### Configuration:
- Theme: `@docusaurus/preset-classic`
- Color scheme matching landing page
- Algolia search placeholder
- GitHub link to (placeholder) repo
- Edit on GitHub links

---

## Phase 3: Core Documentation (iterations 26-40)

### 3.1 Introduction (`docs/intro.md`)
- What is Query Cache Flow?
- Why it exists (problem/solution)
- Key benefits
- Who should use it

### 3.2 Getting Started (`docs/getting-started/`)
- `installation.md` - npm packages, peer deps
- `quick-start.md` - 5-minute setup guide
- `project-structure.md` - Where to put what

### 3.3 Core Concepts (`docs/core-concepts/`)

#### `query-keys.md` - The QueryKey Type
```typescript
export type QueryKey<T> = {
  entity: string;
  method?: 'list' | 'detail' | 'create' | 'update' | 'remove' | string;
  id?: T;
};
```

#### `query-groups.md` - QueryGroup Pattern
```typescript
export interface QueryGroup<T> {
  queryKey: QueryKey<T>;
  invalidates?: QueryKey<T>;
  type?: 'query' | 'mutation';
  normalize?: (data: any) => void;
}
```

#### `crud-factory.md` - createQueryGroupCRUD
The factory that generates all, list, detail, create, update, remove operations with proper invalidation and normalization.

#### `key-injection.md` - inyectKeysToQueries
How to add metadata (auth, scope) to all keys in a query group.

### 3.4 API Reference (`docs/api-reference/`)
- `createQueryGroupCRUD.md`
- `invalidateQueriesForKeys.md`
- `cancelQueriesForKeys.md`
- `inyectKeysToQueries.md`
- `QueryClient-setup.md`

### 3.5 Patterns (`docs/patterns/`)

#### `wrapper-hooks.md` - Wrapping KUBB Hooks
```typescript
// Simple query wrapper
export const useTransactions = () =>
  generatedTransactions({
    query: {
      queryKey: [transactionsQueryGroup.list.queryKey],
    },
  });

// Mutation with invalidation
export const useTransactionCreate = ({ onSuccess, ...rest }) =>
  generatedTransactionCreate({
    mutation: {
      mutationKey: [transactionsQueryGroup.create.queryKey],
      onSuccess: (data, variables, context) => {
        transactionsQueryGroup.create.normalize?.(data);
        invalidateQueriesForKeys(
          transactionsQueryGroup.create.invalidates({ accountId: data.accountId }),
        );
        onSuccess?.(data, variables, context);
      },
      ...rest,
    },
  });
```

#### `cascade-invalidation.md` - When Deleting Cascades
```typescript
remove: {
  invalidates: (id) => [
    ...accountsQueryGroupCRUD.remove.invalidates(id),
    transactionsQueryGroup.all.queryKey,
    recurrencesQueryGroup.all.queryKey,
    movementsQueryGroup.all.queryKey,
  ],
}
```

#### `optimistic-updates.md` - onMutate Pattern
```typescript
onMutate: async ({ threadId, data }) => {
  await queryClient.cancelQueries({ queryKey: [...] });
  const previous = queryClient.getQueryData([...]);
  queryClient.setQueryData([...], (old) => ({ ...old, messages: [...old.messages, newMessage] }));
  return { previous, threadId };
},
onError: (error, variables, context) => {
  queryClient.setQueryData([...], context.previous);
},
```

#### `pagination.md` - Query Params in Keys
```typescript
list: {
  queryKey: (query?: RemindersQueryParams) => ({
    ...remindersQueryGroupCRUD.list.queryKey,
    query,
  }),
}
```

#### `entity-mapping.md` - Backend Integration
```typescript
export const ENTITY_TO_QUERY_KEY_MAP: Record<string, QueryKey<any>> = {
  transactions: transactionsQueryGroup.list.queryKey,
  accounts: accountsQueryGroup.list.queryKey,
  // ...
};

export function getQueryKeysFromAffectedEntities(affectedEntities: string[]) {
  return affectedEntities.map((e) => ENTITY_TO_QUERY_KEY_MAP[e]).filter(Boolean);
}
```

### 3.6 Advanced (`docs/advanced/`)
- `kubb-integration.md` - Full KUBB config walkthrough
- `axios-interceptors.md` - Auth and error handling
- `testing.md` - How to test cache behavior
- `migration-guide.md` - From manual keys to Query Cache Flow

---

## Phase 4: Naive Reviewer Validation (iterations 41-45)

### Task: Pretend you've never seen Query Cache Flow

Read through ALL documentation as if you're a new developer encountering this for the first time. For each page:

1. **Is the concept clear?** Can you understand what it does without prior knowledge?
2. **Are examples sufficient?** Do code samples make sense standalone?
3. **Is the flow logical?** Does reading in order build understanding?
4. **Missing explanations?** What would a newcomer ask?
5. **Jargon check:** Are terms like "normalize", "invalidate", "query group" explained?

### Fix Issues Found:
- Add missing explanations
- Expand confusing sections
- Add more examples where needed
- Create a glossary if necessary

---

## Phase 5: Final Polish (iterations 46-50)

### SEO Optimization (invoke /seo-optimizer):
- Review all page titles and descriptions
- Add frontmatter meta tags to all .md files
- Verify heading hierarchy (h1 → h2 → h3)
- Add internal linking between related pages
- Create a sitemap

### Visual Verification (invoke /playwright-skill):
- Screenshot landing page (desktop + mobile)
- Screenshot at least 3 key documentation pages
- Verify code blocks render with syntax highlighting
- Check navigation works
- Test dark/light mode if implemented

### Final Checklist:
- [ ] Landing page loads and looks professional
- [ ] Docusaurus builds without errors
- [ ] All navigation links work
- [ ] Code examples are copy-pasteable
- [ ] Mobile responsive
- [ ] No placeholder text remaining
- [ ] Consistent terminology throughout

---

## Deliverables Checklist

### Landing Page
- [ ] `landing/index.html` - Complete, styled, responsive
- [ ] Screenshots in `landing/screenshots/`

### Docusaurus Documentation
- [ ] `docs/package.json` - Valid, installable
- [ ] `docs/docusaurus.config.js` - Proper configuration
- [ ] `docs/sidebars.js` - Logical navigation
- [ ] 15+ markdown files covering all concepts
- [ ] Custom CSS matching landing page theme

### Quality Gates
- [ ] Naive reviewer pass completed
- [ ] Playwright visual verification done
- [ ] SEO review completed
- [ ] All code examples tested for accuracy

---

## Reference: Complete Query Cache Flow Architecture

### Core File: `src/queries/index.ts`

```typescript
// QueryKey type - the foundation
export type QueryKey<T> = {
  entity: string;
  method?: 'list' | 'detail' | 'create' | 'update' | 'remove' | string;
  id?: T;
};

// QueryGroup interfaces
export interface QueryGroup<T> {
  queryKey: QueryKey<T>;
  invalidates?: QueryKey<T>;
  type?: 'query' | 'mutation';
  normalize?: (data: any) => void;
}

export interface QueryGroupResolved<T> {
  queryKey: (...args: T[]) => QueryKey<T>;
  invalidates?: (...args: T[]) => QueryKey<T>;
  type?: 'query' | 'mutation';
  normalize?: (data: any) => void;
}

export interface QueryGroupMutationResolved<T> {
  invalidates: (...args: T[]) => QueryKey<T>[];
  queryKey: (...args: T[]) => QueryKey<T>;
  type?: 'query' | 'mutation';
  normalize?: (data: any) => void;
}

export interface QueryGroupCRUD<T> {
  all: QueryGroup<T>;
  list: QueryGroup<T>;
  detail: QueryGroupResolved<T>;
  create: QueryGroup<T>;
  update: QueryGroupMutationResolved<T>;
  remove: QueryGroupMutationResolved<T>;
}

// The magic factory
export const createQueryGroupCRUD = <T = string>(entityName: string): QueryGroupCRUD<T> => {
  // Creates complete CRUD operations with:
  // - Proper query keys for each operation
  // - Automatic invalidation targets
  // - Normalization functions for optimistic updates
};

// Batch invalidation helper
export const invalidateQueriesForKeys = (
  keys: Array<QueryKey<string>>,
  invalidateOptions?: InvalidateQueryFilters,
): void => {
  keys.forEach((key) => {
    queryClient.invalidateQueries({ queryKey: [key], ...invalidateOptions });
  });
};

// Cancel in-flight queries (prevent race conditions)
export const cancelQueriesForKeys = (keys: Array<QueryKey<string>>): void => {
  keys.forEach((key) => {
    queryClient.cancelQueries({ queryKey: [key] });
  });
};

// Inject metadata into all keys recursively
export const inyectKeysToQueries = <T extends Record<string, any>>(
  queries: T,
  extra: Record<string, any>,
): T => {
  // Adds { auth: true, scope: 'user' } etc. to all queryKey objects
};
```

### KUBB Config: `kubb.config.ts`

```typescript
export default defineConfig({
  input: { path: './openapi.json' },
  output: { path: './src/generated', clean: true, barrelType: 'all' },
  plugins: [
    pluginOas(),
    pluginTs(),
    pluginReactQuery({
      client: {
        importPath: '../../services/axios.ts',
        dataReturnType: 'data',
      },
      output: { path: './hooks', barrelType: 'all' },
      mutation: { methods: ['post', 'put', 'delete', 'patch'] },
      query: { methods: ['get'], importPath: '@tanstack/react-query' },
    }),
  ],
});
```

### Query Client: `src/queries/client.ts`

```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
  },
});
export default queryClient;
```

### Feature Query Group Example: `src/features/accounts/queries/index.ts`

```typescript
let accountsQueryGroupCRUD = createQueryGroupCRUD<Account['id']>('accounts');
accountsQueryGroupCRUD = inyectKeysToQueries(accountsQueryGroupCRUD, { auth: true });

export const accountsQueryGroup = {
  ...accountsQueryGroupCRUD,
  remove: {
    ...accountsQueryGroupCRUD.remove,
    invalidates: (id: Account['id']) => [
      ...accountsQueryGroupCRUD.remove.invalidates(id),
      transactionsQueryGroup.all.queryKey,
      recurrencesQueryGroup.all.queryKey,
      transferencesQueryGroup.all.queryKey,
      movementsQueryGroup.all.queryKey,
      remindersQueryGroup.all.queryKey,
    ],
  },
  associates: {
    queryKey: { entity: 'accounts', scope: 'associates', method: 'list' },
  },
};
```

### Wrapper Hook Example: `src/features/accounts/queries/useAccountCreate.ts`

```typescript
export const useAccountCreate = ({ onSuccess, ...rest }: AccountCreateProps) =>
  generatedAccountCreate({
    mutation: {
      mutationKey: [accountsQueryGroup.create.queryKey],
      onSuccess: (data, variables, context) => {
        accountsQueryGroup.create.normalize?.(data);
        queryClient.invalidateQueries({
          queryKey: [accountsQueryGroup.create.invalidates],
        });
        onSuccess?.(data, variables, context);
      },
      ...rest,
    },
  });
```

---

## Loop Configuration

```
max-iterations: 50
completion-promise: <promise>Query Cache Flow-DOCS-COMPLETE</promise>
```

When all deliverables are complete and verified, output:

<promise>Query Cache Flow-DOCS-COMPLETE</promise>
